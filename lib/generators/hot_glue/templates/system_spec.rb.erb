<% item1_addOns = ""
 if (eval(@singular_class).instance_methods.include?(display_class.to_s))
  item1_addOns << "#{display_class}: FFaker::Name.name"
 end
item1_addOns << ", " + @columns_map.collect{|col, col_object|
  col_object.spec_setup_let_arg
}.compact.join(", ")
%>require 'rails_helper'

describe 'interaction for <%= controller_class_name %>' do
  include HotGlue::ControllerHelper
  include ActionView::RecordIdentifier

  <%= @existing_content %>
  <% unless @god %>let(:<%= @auth %>) {create(:<%= @auth.gsub('current_', '') %>)}<% end %>
<%= spec_related_column_lets %>
  let!(:<%= singular %>1) {create(:<%= singular %><%= object_parent_mapping_as_argument_for_specs %> <%= item1_addOns %> )}
<%= objest_nest_factory_setup %> <% unless @god || @existing_content.include?("login_as")%>
  before do
    login_as(<%= @auth %>)
  end <% end %> <% if any_datetime_fields? %>
  let(:current_timezone) {
    <%= @auth_identifier %>.try(:timezone) || Time.now.strftime("%z").to_i/100
  }<% end %>
  describe "index" do
    it "should show me the list" do
      visit <%= path_helper_plural %>
<%=
(@columns - @attachments.keys.collect(&:to_sym)).map { |col|
  type = eval("#{singular_class}.columns_hash['#{col}']").type

  case type
  when :datetime
    "      " + ["expect(page).to have_content(#{singular}#{1}.#{col}.in_time_zone(current_timezone).strftime('%m/%d/%Y @ %l:%M %p ').gsub('  ', ' ') + timezonize(current_timezone)  )"].join("\n      ")
  when :integer
    if !col.ends_with?("_id")
      "      " + ["expect(page).to have_content(#{singular}#{1}.#{col})"].join("\n      ")
    end
  when :uuid
    assoc_name = col.to_s.gsub('_id','')
    association = eval("#{singular_class}.reflect_on_association(:#{assoc_name})")
    "      " + ["expect(page).to have_content(#{singular}#{1}.#{assoc_name}.#{HotGlue.derrive_reference_name(association.class_name)})"].join("\n      ")
  when :enum
    if(eval("#{singular_class}.respond_to?(:#{col}_labels)"))
     "      " + "expect(page).to have_content(#{singular_class}.#{col}_labels[#{singular}#{1}.#{col}])"
    else
     "      " + "expect(page).to have_content(#{singular}1.#{col})"
    end

  when :boolean
    "      " + ["expect(page).to have_content(#{singular}#{1}.#{col} ? 'YES' : 'NO')"].join("\n      ")
  else
    "      " + ["expect(page).to have_content(#{singular}#{1}.#{col})"].join("\n      ")
  end

}.join("\n")
      %>
    end
  end

<% unless @no_create %>  describe "new & create" do
    it "should create a new <%= singular.titlecase %>" do
      visit <%= path_helper_plural %>
      click_link "<%= @new_button_label %>"
      expect(page).to have_selector(:xpath, './/h3[contains(., "<%= @new_button_label %>")]')
<%= capybara_make_updates(:create) %>
      click_button "Save"
      expect(page).to have_content("Successfully created")

<%="      " +

@columns_map.map{ |col, col_object|
  if @attachments.keys.collect(&:to_sym).include?(col)
  elsif @show_only.include?(col)
  else
      col_object.spec_make_assertion
  end

  }.compact.join("\n      ")
  %>
    end
  end<% end %>

<% unless @no_edit %>
  describe "edit & update" do
    it "should return an editable form" do
      visit <%= path_helper_plural %>
      find("a.edit-<%= singular %>-button[href='/<%= namespace_with_slash %><%= plural %>/#{<%= singular %>1.id}/edit']").click

      expect(page).to have_content("Editing #{<%= singular %>1.<%= @display_class %>.squish || "(no name)"}")
<%= capybara_make_updates(:update) %>
      click_button "Save"
      within("turbo-frame#<%= @namespace %>__#{dom_id(<%= singular %>1)} ") do
<%= ((@columns - @attachments.keys.collect(&:to_sym)) - (@show_only+@update_show_only)).map { |col|
      type = eval("#{singular_class}.columns_hash['#{col}']").type

      if type == :uuid || (type == :integer && col.to_s.ends_with?("_id"))
        assoc = col.to_s.gsub('_id', '')
        class_name = eval("#{@singular_class}.reflect_on_association(:#{assoc})").class_name
      "        expect(page).to have_content(#{assoc}1.#{HotGlue.derrive_reference_name(class_name)})"

      elsif type == :boolean
      '        expect(page).to have_content(new_' + col.to_s + ' ? "YES" : "NO")'

      elsif type == :enum && eval("#{singular_class}.respond_to?(:#{col}_labels)")
       "        expect(page).to have_content(#{singular_class}.#{col}_labels[new_#{col}])"
      elsif type == :string && eval("#{singular_class}.respond_to?(:devise_modules)") &&
           #devise confirmable makes email updates go into unconfirmed_email
           eval("#{singular_class}.devise_modules.include?(:confirmable)") && col.to_s == "email"
            "        expect(page).to have_content(#{ singular }1.#{col.to_s})"
      elsif type == :datetime
            "        expect(page).to have_content(new_#{col.to_s}.in_time_zone(current_timezone).strftime('%m/%d/%Y @ %l:%M %p ') + timezonize(current_timezone))"
      else
            "        expect(page).to have_content(new_#{col.to_s})"
      end
    }.compact.join("\n")
    %>
      end
    end
  end <% end %>

<% unless @no_delete %>  describe "destroy" do
    it "should destroy" do
      visit <%= path_helper_plural %>
      accept_alert do
        find("form[action='<%= namespace_with_dash %>/<%= plural %>/#{<%= singular %>1.id}'] > input.delete-<%= singular %>-button").click
      end
      expect(page).to_not have_content(<%= singular %>1.<%= @display_class %>)
      expect(<%= singular_class %>.where(id: <%= singular %>1.id).count).to eq(0)
    end
  end<% end %>
end

